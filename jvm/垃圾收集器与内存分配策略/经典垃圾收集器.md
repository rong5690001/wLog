这篇文章一起来学习几个问题：

1. 各个收集器的优缺点是什么？
2. 在什么情况下适合用什么收集器？
3. 收集器如何组合使用？

## 一、Serial收集器

​		这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。运行过程如图：

![image-20201009151149683](/Users/user/Library/Application Support/typora-user-images/image-20201009151149683.png)

**优点**

- 简单高效（与其他收集器的单线程相比）
- 额外内存消耗最小
- 没有线程交互的开销

**缺点**

在进行垃圾收集时会暂停其他所有工作线程，直到它收集结束。

## 二、ParNew收集器

​		ParNew收集器实质上是Serial收集器的多线程并行版本。运行过程如图：

![image-20201009151728167](/Users/user/Library/Application Support/typora-user-images/image-20201009151728167.png)

​		它是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：**<u>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</u>**

## 三、Parallel Scavenge收集器

​		Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。

​		Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的**<u>吞吐量（Throughput）</u>**。

**吞吐量（Throughput）**

![image-20201009153435979](/Users/user/Library/Application Support/typora-user-images/image-20201009153435979.png)

​		停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

​		Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。

**-XX：MaxGCPauseMillis参数**

允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

**-XX：GCTimeRatio参数**

参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。

**-XX：+UseAdaptiveSizePolicy**

这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

​		

注：自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

## 四、Serial Old收集器

​		Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。运行过程如图：

![image-20201009160439205](/Users/user/Library/Application Support/typora-user-images/image-20201009160439205.png)

## 五、Parallel Old收集器

​		Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

​		在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。运行过程如图：![image-20201009160644905](/Users/user/Library/Application Support/typora-user-images/image-20201009160644905.png)

## 六、CMS收集器

​		CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。适合较为关注服务的响应速度这类应用的需求。

​		CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

**初始标记**

只是标记一下GCRoots能直接关联到的对象，速度很快。但是需要“Stop The World”。

**并发标记**

并发标记阶段就是从GCRoots的直接关联对象开始遍历整个对象图的过程，这个过程耗时比较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

**重新标记**

重新标记阶段则是为了**<u>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</u>**（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

**并发清除**

清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。



由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的阶段。![image-20201009164705408](/Users/user/Library/Application Support/typora-user-images/image-20201009164705408.png)

**优点**

并发收集、低停顿。

**缺点**

1. CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）/4。当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。
2. CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“并发失败”（Concurrent Mode Failure）进而导致另一次完全“Stop The World”的Full GC的产生。。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。
3. CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。

## 七、Garbage First收集器

​		