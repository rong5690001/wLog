这篇文章咱们一起来学习几个问题：

1. Java中方法、字段名的最大长度是多少？
2. 哪些字面量会进入常量池中?
3. 内部类的默认构造函数是什么样的？
4. 方法里面的代码是怎么存放的？
5. 内部类是什么时候拿到外部类的引用？		
6. 为什么没有参数的方法里args_size为1？
7. 方法里为什么要有this指针。



​		代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

​		如果全世界所有计算机的指令集就只有x86一种，操作系统就只有Windows一种，那也许就不会有Java语言的出现。

​		java虚拟机执行的是class文件，这又提供了语言无关性。如下图：![image-20201012111024934](/Users/user/Library/Application Support/typora-user-images/image-20201012111024934.png)

#### **类文件结构脑图**

![类文件结构](/Users/user/wLog/jvm/虚拟机执行子系统 /类文件结构.png)

​		Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

​		Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这两种数据类型为基础。

#### **无符号数**

无符号数属于基本的数据类型，以<u>**u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节**</u>的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

#### **表**

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由下表所示的数据项按严格顺序排列构成。		![image-20201012141220555](/Users/user/Library/Application Support/typora-user-images/image-20201012141220555.png)

![image-20201012152602738](/Users/user/Library/Application Support/typora-user-images/image-20201012152602738.png)

## 一、魔数与Class文件的版本

​		每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。

​		紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。

## 二、常量池

​		紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。

​		由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。这个容量计数是从1而不是0开始的，所以数据项的数量为constant_pool_count-1。

​		常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

#### **字面量（Literal）**

字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。

#### **符号引用（Symbolic References）**

符号引用则属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）



​		Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接（具体见第7章）。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

​		常量池中每一项常量都是一个表，常量类型如下图：![image-20201013103238831](/Users/user/Library/Application Support/typora-user-images/image-20201013103238831.png)

​		每一个常量都有自己的数据结构。如上表中的CONTANT_Class_info的结构如下：

![image-20201013104538950](/Users/user/Library/Application Support/typora-user-images/image-20201013104538950.png)

​		tag是标志位，它用于区分常量类型；name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量。

​		再来看一下CONTANT_Utf8_info类型的常量，如下：

![image-20201013104759877](/Users/user/Library/Application Support/typora-user-images/image-20201013104759877.png)

​		length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。

#### **常量池中的17种数据类型的结构总表**

![image-20201013113315413](/Users/user/Library/Application Support/typora-user-images/image-20201013113315413.png)

![image-20201013113407886](/Users/user/Library/Application Support/typora-user-images/image-20201013113407886.png)

![image-20201013113351755](/Users/user/Library/Application Support/typora-user-images/image-20201013113351755.png)

#### **常量池UTF-8字符串结构**

![image-20201014094958641](/Users/user/Library/Application Support/typora-user-images/image-20201014094958641.png)

## 三、访问标志

​		在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息。具体的标志位以及标志的含义见下表：![image-20201013151723465](/Users/user/Library/Application Support/typora-user-images/image-20201013151723465.png)

#### **访问标志实例**

![image-20201014094849326](/Users/user/Library/Application Support/typora-user-images/image-20201014094849326.png)

## 四、类索引、父类索引与接口索引集合

​		类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合。		

​		类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为**CONSTANT_Class_info**的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。		

​		对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。

**类索引、父类索引与接口索引集合实例**

![image-20201014094817111](/Users/user/Library/Application Support/typora-user-images/image-20201014094817111.png)

## 五、字段表集合

​		字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

#### **字段表结构**

![image-20201013170832555](/Users/user/Library/Application Support/typora-user-images/image-20201013170832555.png)

- access_flags为字段修饰符，表示字段访问范围
- name_index为字段名在常量表中的索引，表示字段名称
- descriptor_index字段描述符在常量表中的索引（索引对应的都是字符串），表示字段类型

#### **字段访问标志(access_flags)**

![image-20201013170958719](/Users/user/Library/Application Support/typora-user-images/image-20201013170958719.png)

这里非互斥的标志同时出现时，标志值会相加。例如ACC_PRIVATE和ACC_STATIC同时出现时，标志值为0x0002+0x0008 = 0x000a。所以各标志位相加一定是一个唯一的值，不会出现冲突。

#### **描述符标识字符含义**

![image-20201013171827249](/Users/user/Library/Application Support/typora-user-images/image-20201013171827249.png)

对于**<u>数组类型</u>**，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。



​		字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在**<u>内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</u>**

#### **字段表结构实例**

![image-20201014094735014](/Users/user/Library/Application Support/typora-user-images/image-20201014094735014.png)

## 六、方法表集合

#### **方法表结构**

![image-20201013170832555](/Users/user/Library/Application Support/typora-user-images/image-20201013170832555.png)

- access_flags为方法修饰符，表示方法访问范围
- name_index为方法名在常量表中的索引，表示方法名称
- descriptor_index方法描述符在常量表中的索引（索引对应的都是字符串），表示方法的参数和返回类型

用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。

#### **方法访问标志**

![image-20201013174716981](/Users/user/Library/Application Support/typora-user-images/image-20201013174716981.png)

#### **方法表结构实例**

![image-20201014095117554](/Users/user/Library/Application Support/typora-user-images/image-20201014095117554.png)

​		与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法。

## 七、属性表集合

​		Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。

#### **虚拟机规范预定义的属性**

![image-20201014103037653](/Users/user/Library/Application Support/typora-user-images/image-20201014103037653.png)

![image-20201014103049603](/Users/user/Library/Application Support/typora-user-images/image-20201014103049603.png)

​		对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。

#### **属性表结构**

![image-20201014103551704](/Users/user/Library/Application Support/typora-user-images/image-20201014103551704.png)

#### **Code属性**

Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示。![image-20201014103719005](/Users/user/Library/Application Support/typora-user-images/image-20201014103719005.png)

- attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称。
- attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。
- max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。
- max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。
- code_length代表字节码长度。
- code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。	



​		Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为**<u>代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）</u>**两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。

#### 异常表的属性表结构 

![image-20201015104903385](/Users/user/Library/Application Support/typora-user-images/image-20201015104903385.png)

​		这些字段的含义为：如果当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时(指finally)，代表任意异常情况都需要转到handler_pc处进行处理。

注：此处字节码的“行”是一种形象的描述，指的是字节码相对于方法体开始的**<u>偏移量</u>**，而不是Java源码的行号，下同。

#### Exceptions属性

​		这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。它的结构见表6-17。

表6-17 Exceptions属性结构

![image-20201015143634508](/Users/user/Library/Application Support/typora-user-images/image-20201015143634508.png)

​		此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。

#### LineNumberTable属性

​		LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。LineNumberTable属性的结构如表6-18所示。

表6-18 LineNumberTable属性结构

![image-20201015152629000](/Users/user/Library/Application Support/typora-user-images/image-20201015152629000.png)

​		line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包含start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。

#### LocalVariableTable及LocalVariableTypeTable属性

##### LocalVariableTable属性

​		LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。LocalVariableTable属性的结构如表6-19所示。

表6-19 LocalVariableTable属性结构
![image-20201015162732843](/Users/user/Library/Application Support/typora-user-images/image-20201015162732843.png)

​		其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。

表6-20 local_variable_info项目结构

![image-20201015162823099](/Users/user/Library/Application Support/typora-user-images/image-20201015162823099.png)

- start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。
- name_index：代表了局部变量的名称。指向常量池中的CONSTANT_Utf8_info型常量的索引。
- descriptor_index：代理局部变量的描述符。也是索引。
- index：这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个。

##### LocalVariableTypeTable属性（泛型）

​		这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。

#### SourceFile及SourceDebugExtension属性

##### SourceFile属性

​		SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。**<u>如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</u>**这个属性是一个定长的属性，其结构如表6-21所示。

表6-21 SourceFile属性结构

![image-20201016144806282](/Users/user/Library/Application Support/typora-user-images/image-20201016144806282.png)

- sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。

##### SourceDebugExtension属性

​		为了方便在编译器和动态生成的Class中加入供程序员使用的自定义内容，在JDK 5时，新增了SourceDebugExtension属性**<u>用于存储额外的代码调试信息</u>**。<u>**典型的场景是在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号。**</u>JSR 45提案为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息，譬如让程序员能够快速从异常堆栈中定位出原始JSP中出现问题的行号。SourceDebugExtension属性的结构如表6-22所示。

表6-22 SourceDebugExtension属性结构

![image-20201016154457170](/Users/user/Library/Application Support/typora-user-images/image-20201016154457170.png)

- debug_extension存储的就是额外的调试信息，是一组通过变长UTF-8格式来表示的字符串。一个类中最多只允许存在一个SourceDebugExtension属性。

#### ConstantValue属性

​		ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。目前Oracle公司实现的Javac编辑器，只有在同时用final和static来修饰一个基本类型或者java.lang.String的话，才会生成ContantValue属性来进行初始化。

表6-23 ConstantValue属性结构

![image-20201019102540808](/Users/user/Library/Application Support/typora-user-images/image-20201019102540808.png)