这篇文章一起来学习几个问题：

1. 什么是分代收集理论？
2. 分代收集理论有哪些算法去实现？
3. 各个算法的优缺点？
4. 如何针对不同需求用不同的算法？



​		从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。这里介绍的都是追踪式垃圾收集的范畴。

## 一、分代收集理论

​		大多数的虚拟机都是遵循分代收集理论设计的，是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1. **<u>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</u>**
2. **<u>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</u>**

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储，再用不种的回收算法回收这些区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

​		这里不同的区域一般分为：新生代（Young Generation）和老年代（Old Generation）两个区域。

#### 新生代

​		每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

#### 老年代

​		经历过数次(一般是15次)GC仍然还存活的对象，一般只有在堆内存不够用的时候才会进行垃圾回收。



​		当然分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，**<u>对象之间会存在跨代引用</u>**。新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：
3）**<u>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</u>**

​		存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

#### 不同分代的GC名词

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  ■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  ■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
  ■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

## 二、标记清除算法

​		最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。

​		后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。

#### 缺点

1. **<u>执行效率不稳定</u>**，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
2. **<u>内存空间的碎片化问题</u>**，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

标记-清除算法的执行过程如图所示。

![image-20200930154305604](/Users/user/Library/Application Support/typora-user-images/image-20200930154305604.png)

## 三、标记-复制算法

​		标记-复制算法是目前大多数虚拟机优先采用的算法。

​		标记-复制算法是为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

#### 优点

1. 根据弱分代假说每次垃圾收集只要复制少数对象。
2. 每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

#### 缺点

将可用内存缩小为了原来的一半，空间浪费未免太多了一点。



标记-复制算法的执行过程如图所示。

![image-20200930155049888](/Users/user/Library/Application Support/typora-user-images/image-20200930155049888.png)

#### Appel式回收

​		Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

​		可以看这个视频，通过动画的方式直接的展示回收过程(https://www.ixigua.com/6835238917629805067?id=6834743668876771843&logTag=OMcdZn8i3OGCGxfSn8SWF)

## 四、标记-整理算法

​		标记-整理算法标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图所示。![image-20200930160459283](/Users/user/Library/Application Support/typora-user-images/image-20200930160459283.png)

​		标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：

1. 移动的话使内存回收更复杂，需要移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作。
2. 不移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。（内存分配器和内存访问器这里不讨论）

从垃圾收集的停顿时间来看，不移动对象**<u>停顿时间</u>**会更短，甚至可以不需要停顿，但是从整个程序的**<u>吞吐量</u>**来看，移动对象会更划算。

#### 吞吐量（Throughput）

​		吞吐量就是**CPU用于运行用户代码的时间**与**CPU总消耗时间**的比值，即**吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。



​		HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。

#### 两者并用的方案

​		让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。

