# java运行时数据区

[TOC]

![166786b5cf6d7f95](/Users/laura/Desktop/166786b5cf6d7f95.png)

​																			JDK8之前的数据区

![image-20200919153609023](/Users/laura/Desktop/20180812235058303.jpg)

​																JDK8之后的数据区



## 一、程序计数器

​		程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器（每个线程都有自己独立的程序计数器）。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

------

##### --为什么需要程序计数器？

​		首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。

​		如果多线程理解为一个人在看多本书，那么程序计数器就是书签，你来回切换看不同书的时候，用来记录你之前看到的位置。

## 二、Java虚拟机栈

​		虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

## 三、本地方法栈

​		本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

## 四、Java堆

​		Java堆被用来存放对象实例和数组，所有线程共享的一块内存区域。（但是对象也有可能存放在栈中）。

注：堆通常是一个可以被看做一棵[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232)的数组对象。

​		从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代。

<u>疑问：对象的句柄存在哪？</u>

## 五、方法区

​		方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 六、运行时常量池

​		运行时常量池是方法区的部分，用于存放编译期生成的各种字面量和符号引用。

## 七、直接内存

​		直接内存并不是虚拟机运行时数据区的一部分。

​		在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

注：I/O详解可以参考https://juejin.im/post/6844903910348603405

​		NIO参考 ：https://www.jianshu.com/p/362b365e1bcc

