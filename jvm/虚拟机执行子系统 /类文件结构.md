

![屏幕快照 2020-10-11 上午10.02.03](/Users/laura/Desktop/屏幕快照 2020-10-11 上午10.02.03.png)

![屏幕快照 2020-10-11 上午10.03.19](/Users/laura/Desktop/屏幕快照 2020-10-11 上午10.03.19.png)

一、跨平台的本质

本质是因为汇编指令的不同。（AT&T汇编风格、Intel汇编风格 ）

二、为什么选择JVM

- 优秀的内存管理：内存模型
- 精简的字节码指令+高效率的执行引擎
- 安全可扩展的类加载器系统
- 高性能+低延迟的垃圾收集器



**Class对象是什么？**

存放class元数据。存在方法区。



**方法区**

元空间：放在本地内存上（也可以叫直接内存、操作系统内存、native memory）



**元空间调优实战**

1. 最小、最大设置成一样。为什么？防止内存抖动
2. 设置成多少？物理内存的1/32左右。工具arthas、visualvm

3. 空间多预留20%-30%



**程序计数器**

OD软件，注意和操作系统的程序计数器的区别，操作系统的程序计数器有对应的寄存器。而JVM的程序计数器是index，用代码实现的。



**虚拟机栈**

栈帧

​		动态链接（直接地址）：存放的是这个方法在方法区的内存地址。

​		返回地址（恢复现场）：调用它的方法在方法区的内存地址。

​		局部变量表：



**一个方法执行完JVM需要做的事情 ：**

1. 恢复局部表指针
2. 恢复操作数栈指针
3. 恢复程序计数器
4. 如果方法有返回地址，需要返回
5. 清理栈帧（程序计数器做的）



**new操作不是原子操作**

因为new有四步操作

```java
0 new #2 <com/rong/block/pojo/User>
3 dup
4 invokespecial #3 <com/rong/block/pojo/User.<init>>
7 astore_1
```

DCL 双重检测 + volatile



**this指针是如何赋值的？**

执行aload_1的时候。



每个非静态方法，局部变量表index=0的位置存放的是this指针。



**虚拟机栈->方法区**

​		动态链接 



**堆->方法区**

​		klass Pointer

​				对象指向所有类的Class对象的内存地址



**方法区->堆**

public staic Test4 test4 = new Test4();

静态变量是Class对象的一个属性，存储在方法区。

